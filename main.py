import nest_asyncio
nest_asyncio.apply()  # Permet d'utiliser des boucles imbriqu√©es

import asyncio
import logging
import os
import threading
from datetime import datetime
from flask import Flask
import aiosqlite
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# Configuration du logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Flask app pour garder le bot actif
app = Flask(__name__)

@app.route("/")
def home():
    return f"Bot actif et op√©rationnel depuis {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

# Token du bot et ID admin
TOKEN = "7184666905:AAFd2arfmIFZ86cp9NNVp57dKkH6hAVi4iM"
ADMIN_ID = 123456789  # Remplace par ton identifiant Telegram

# M√©dias
INTRO_VIDEO = "https://drive.google.com/uc?export=download&id=1NREjyyYDfdgGtx4r-Lna-sKgpCHIC1ia"
MAIN_IMAGE = "https://i.ytimg.com/vi/KolFup7TxOM/hq720.jpg"
BOTTOM_IMAGE = "https://aviator.com.in/wp-content/uploads/2024/04/Aviator-Predictor-in-India.png"

PAYMENT_PROOF_IMAGES = [
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png"
]

INFO_IMAGES = [
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png",
    "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Circle_sign_2.svg/1024px-Circle_sign_2.svg.png"
]

def create_keyboard():
    """Cr√©e le clavier avec les boutons."""
    keyboard = [
        [InlineKeyboardButton("üéØ Informations sur les bots", callback_data="info_bots")],
        [InlineKeyboardButton("üí∞ Retrait du casino", callback_data="casino_withdrawal")],
        [InlineKeyboardButton("üì± Contacter l'expert", url="https://t.me/judespronos")]
    ]
    return InlineKeyboardMarkup(keyboard)

def create_program_button():
    """Cr√©e le bouton pour obtenir le programme."""
    keyboard = [[InlineKeyboardButton("üöÄ OBTENIR LE PROGRAMME MAINTENANT", url="https://t.me/judespronos")]]
    return InlineKeyboardMarkup(keyboard)

# --- Gestion de la base de donn√©es SQLite pour un stockage persistant des utilisateurs ---

DB_PATH = "users.db"

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                chat_id INTEGER PRIMARY KEY
            )
        """)
        await db.commit()

async def add_user(chat_id: int):
    """Ajoute un utilisateur dans la base de donn√©es."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT OR IGNORE INTO users (chat_id) VALUES (?)", (chat_id,))
        await db.commit()

async def get_all_users():
    """R√©cup√®re tous les utilisateurs depuis la base de donn√©es."""
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT chat_id FROM users") as cursor:
            rows = await cursor.fetchall()
            return [row[0] for row in rows]

# --- Commandes du bot ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """G√®re la commande /start, enregistre l'utilisateur et envoie des messages de bienvenue."""
    chat_id = update.effective_chat.id
    await add_user(chat_id)
    try:
        # Envoie la vid√©o d'introduction
        await context.bot.send_video(
            chat_id=chat_id,
            video=INTRO_VIDEO,
            caption="üéÆ D√©couvrez notre m√©thode r√©volutionnaire ! üé∞"
        )
        message = f"""üéØ BILL GATES, BONJOUR ‚ùóÔ∏è

Je suis un programmeur v√©n√©zu√©lien et je connais la combine pour retirer l'argent du jeu des casinos.

‚úÖ 1800 personnes ont d√©j√† gagn√© avec moi. Et je peux vous garantir en toute confiance que vous gagnerez.

üí´ Vous pouvez gagner de l'argent sans rien faire, car j'ai d√©j√† fait tout le programme pour vous.

üî• Derni√®re mise √† jour: {datetime.now().strftime('%d/%m/%Y')}"""
        reply_markup = create_keyboard()
        await update.message.reply_photo(
            photo=MAIN_IMAGE,
            caption=message,
            reply_markup=reply_markup
        )
        await context.bot.send_photo(
            chat_id=chat_id,
            photo=BOTTOM_IMAGE,
            caption="üèÜ Rejoignez les gagnants d√®s aujourd'hui !"
        )
        logger.info(f"Nouvel utilisateur enregistr√©: {chat_id}")
    except Exception as e:
        logger.error(f"Erreur lors du d√©marrage pour le chat {chat_id}: {e}")

async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """G√®re les clics sur les boutons."""
    query = update.callback_query
    await query.answer()
    chat_id = update.effective_chat.id
    try:
        if query.data == "casino_withdrawal":
            await context.bot.send_message(
                chat_id=chat_id,
                text="""üé∞ PREUVES DE PAIEMENT R√âCENTES üé∞

üíé Ces retraits ont √©t√© effectu√©s dans les derni√®res 24 heures
‚ú® Nos utilisateurs gagnent en moyenne 500‚Ç¨ par jour
‚ö°Ô∏è M√©thode 100% automatis√©e et garantie
üîí Aucun risque de perte

üëá Voici les preuves en images üëá"""
            )
            media_group = [InputMediaPhoto(media=url) for url in PAYMENT_PROOF_IMAGES]
            await context.bot.send_media_group(
                chat_id=chat_id,
                media=media_group
            )
            await context.bot.send_message(
                chat_id=chat_id,
                text="üåü Pr√™t √† commencer votre succ√®s ?",
                reply_markup=create_program_button()
            )
        elif query.data == "info_bots":
            await context.bot.send_message(
                chat_id=chat_id,
                text="""ü§ñ NOTRE TECHNOLOGIE UNIQUE ü§ñ

‚úÖ Intelligence artificielle avanc√©e
üéØ Taux de r√©ussite de 98.7%
üí´ Mise √† jour quotidienne des algorithmes
‚ö°Ô∏è Plus de 1800 utilisateurs satisfaits

üëá D√©couvrez notre syst√®me en images üëá"""
            )
            media_group = [InputMediaPhoto(media=url) for url in INFO_IMAGES]
            await context.bot.send_media_group(
                chat_id=chat_id,
                media=media_group
            )
            await context.bot.send_message(
                chat_id=chat_id,
                text="üöÄ Pr√™t √† r√©volutionner vos gains ?",
                reply_markup=create_program_button()
            )
        logger.info(f"Bouton {query.data} cliqu√© par l'utilisateur {chat_id}")
    except Exception as e:
        logger.error(f"Erreur lors du traitement du bouton pour le chat {chat_id}: {e}")
        await context.bot.send_message(
            chat_id=chat_id,
            text="Une erreur est survenue. Veuillez r√©essayer."
        )

async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Commande /broadcast r√©serv√©e √† l'admin.
    Envoie un message (pass√© en argument) √† tous les utilisateurs enregistr√©s.
    Utilise un contr√¥le de la concurrence pour √©viter de saturer l'API Telegram.
    """
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Vous n'avez pas la permission d'utiliser cette commande.")
        return

    message = " ".join(context.args)
    if not message:
        await update.message.reply_text("Veuillez fournir un message √† diffuser.")
        return

    user_ids = await get_all_users()
    count = 0
    semaphore = asyncio.Semaphore(30)  # Limite de 30 envois simultan√©s

    async def send_to_user(user_id):
        nonlocal count
        async with semaphore:
            try:
                await context.bot.send_message(chat_id=user_id, text=message)
                count += 1
                await asyncio.sleep(0.1)  # Pause pour √©viter de saturer l'API
            except Exception as e:
                logger.error(f"Erreur lors de l'envoi au chat {user_id}: {e}")

    tasks = [asyncio.create_task(send_to_user(user_id)) for user_id in user_ids]
    await asyncio.gather(*tasks)
    await update.message.reply_text(f"Message broadcast envoy√© √† {count} utilisateurs.")

def keep_alive():
    """Lance le serveur Flask pour garder le bot actif."""
    def run():
        app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 10000)))
    thread = threading.Thread(target=run)
    thread.start()

async def main():
    """Fonction principale pour d√©marrer le bot."""
    try:
        await init_db()  # Initialiser la base de donn√©es
        application = Application.builder().token(TOKEN).build()

        # Ajout des gestionnaires de commandes et callbacks
        application.add_handler(CommandHandler("start", start_command))
        application.add_handler(CallbackQueryHandler(handle_button))
        application.add_handler(CommandHandler("broadcast", broadcast))  # Commande r√©serv√©e √† l'admin

        # D√©marrage du serveur Flask
        keep_alive()

        logger.info("Bot d√©marr√© avec succ√®s!")
        await application.run_polling()
    except Exception as e:
        logger.critical(f"Erreur fatale: {e}")
        raise

if __name__ == "__main__":
    asyncio.get_event_loop().run_until_complete(main())
